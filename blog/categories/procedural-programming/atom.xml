<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Procedural Programming | Learning Ruby]]></title>
  <link href="http://ppj.github.io/blog/categories/procedural-programming/atom.xml" rel="self"/>
  <link href="http://ppj.github.io/"/>
  <updated>2014-09-04T11:34:36+10:00</updated>
  <id>http://ppj.github.io/</id>
  <author>
    <name><![CDATA[Prasanna Joshi]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[How to Start Writing a (Procedural) Program]]></title>
    <link href="http://ppj.github.io/blog/2014/08/18/how-to-start-writing-a-procedural-program/"/>
    <updated>2014-08-18T13:13:27+10:00</updated>
    <id>http://ppj.github.io/blog/2014/08/18/how-to-start-writing-a-procedural-program</id>
    <content type="html"><![CDATA[<p>I have starter trouble&#8230; always. I either spend way too much time &#39;planning&#39; and &#39;collecting information&#39; when i want to start something new, or, the other extreme (but less often), just dive right into it and then suffer due to under preparation.</p>

<!-- more -->

<p>The fundamental technique i learnt during the first course in the first <a href="http://www.gotealeaf.com/">TeaLeaf</a> course on Ruby basics was how to start writing a program. In other words, how much preparation is just enough to start writing a procedural program.</p>

<p>A quick side-note: Although, procedural programming is (almost) a thing of the past, and all for the right reasons, it is still a great way to start learning programming IMO. The primary reason, i believe, is our brains are wired to think sequentially or serially: first do this, then get the result, then do that&#8230; and so on. At least mine is.</p>

<p>So to get over that starting trouble, the technique to start writing a program that best helped me is writing psuedo-code. &quot;Pseudo&quot; as in made up syntax, not bother about whether it will run, because it will not! The psuedo-code is almost plain English, or very close to it. Just enough to guide you in writing the actual code.</p>

<p>Just jot down the logical steps (loops, conditionals, operations) you think are required to solve the programming problem. One rule i stuck to when doing this exercise is: use consistent indentation for readability.</p>

<p>As an example, this is the psuedo code i wrote for a console-based player-vs-computer Tic-Tac-Toe game:</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">Start with an empty 3x3 board
until board full or winner
  ask player to chose empty square to mark his/her &#39;X&#39;
  display board
  if player won?
    announce winner and end game
  else if board full?
    end game
  else
    generate a random number and let the computer choose an empty square to mark its &#39;O&#39;
  end
  display board
  if computer won
    announce winner and end game
  elsif board full?
    end game
  end
end
</code></pre></div>
<div>Some features of this technique are:</div>

<ul>
<li>it highlights my logic of developing a solution</li>
<li>it helps to keep focus on the current coding task</li>
<li>it helps to bring focus back to the next coding task if the previous one took longer than normal for whatever reasons (new language, syntactical errors)</li>
<li>it need not be perfect (or updated all the time for small changes in the actual implementation)</li>
<li>The final Ruby code for this simple application (if it can be called that!) can be found <a href="https://github.com/ppj/tealeaf1_Lesson1/blob/master/tic_tac_toe.rb">here</a> </li>
</ul>
]]></content>
  </entry>
  
</feed>
